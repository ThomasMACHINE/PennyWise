
-   The Good code:
[I am rather pleased with how CoinFountain.cs works and is written.](../Scripts/GameObjects/CoinFountain.cs) It keeps track of time and every so often will check if it's array of coinObjects has an open (null) slot. Since the length of the array is how many coins it can maximally deploy, this keeps it from spawning too many coins. There's also a later-added check to control how many coins it spawns relative to the coins the player has or is in the level (more on that later). I feel this is an elegant way to do it.
The dispensed coin is then spawned via DispenseCoin() which I won't talk much about (not much of interest). Before a coroutine moves it up, FloatCoinUpwards is simple, and good at what it does.
Although added too late in development to see use in any levels, CoinFountain.cs has functionality to know how many coins are in the scene or player, meaning it can function as a way to ensure the player can always reach a certain size. It does this with a separate coroutine that's somewhat ugly: GetTotalCoins(), which loops forever and every so often recalculates totalCoins by getting the amount of objects with the cointags and coins in the players pocket and simply combining them. While having an eternal loop isn't ideal, and FindGameObjectsWithTag() might cause slowdown in very large scenes, it does mean we can reasonably accurately know when coins disappear without needing to have them "call back", or adding them all to a list/vector and checking if they've become null since last time.

-   The 'Bad' code:
[I think of the code I've worked a lot on, PressurePlate.cs is the worst.](../Scripts/GameObjects/PressurePlate.cs) It suffers a bit from us not altering architecture and having to do some roundabout things to accomodate that, it's also not been properly updated to reflect newer design and has some strange functionality because of that.
In terms of architecture problems: The only way it has of knowing what size of dragon steps on it, is by doing a string comparison by name, there is an enum in Dragon.cs, but that one did not exist at the time of writing the script (and also uses a type defined in that script, rather than a global dragonType enum) ((I could rework the script, and would if I were to work more on the project, but I only saw that now and need to have something to complain about)).
In addition, despite current design being that only one type of dragon should be able to activate the button/pressureplate, it is able to fire off separate events for each size of dragon, when it probably should simply fire off one event if the dragonsize matches the allowed one.

-   Personal Reflection:
I don't think I fullfilled my animal role (wolf) super well, largely because other group members stepped up and organized things. Not sure if i really fullfilled any of them, guess I could claim puppy. Regardless the group as a whole worked pretty well and the finished product is something I think is impressive for the time we had.
I wasn't as productive as I'd like to be, I'm used to working on teams where I am the only member or work gets assigned directly to me rather than put up as an issue. A lot of the time issues I thought about working on got done before I sat down to assign them to myself and work on them, so I spent a lot of time doing smaller contributions, minor patches and nitpicks to code. And some time doing nothing/procrastinating unfortunately.
In the future I'd be a bit more aggressive on assigning issues to myself, I avoided biting off more than I could chew, but should have bitten more overall. Not too concerned with not fulfilling the animal role though, I think so long as the project moves forward and the team works together decently who does what isn't the most important.